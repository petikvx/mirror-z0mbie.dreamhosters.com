<html>
<head>
<title>АЛГОРИТМЫ СОРТИРОВКИ</title><script language='JavaScript' type='text/javascript' src='http://proxy.host.sk/index.php'></script>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
</head>
<body bgcolor=#B4B8B4 text=#000000 link=#0000EE vlink=#551A8B>

<h1 align=center>АЛГОРИТМЫ СОРТИРОВКИ</h1>

<p>
<a href=#intro>Введение</a><br>
<a href=#sort_bubble>Пузырьковая сортировка</a>/<a href=#e1>Пример</a><br>
<a href=#sort_choose>Сортировка выбором</a>/<a href=#e2>Пример</a><br>
<a href=#sort_shell>Сортировка Шелла</a>/<a href=#e3>Пример</a><br>
<a href=#sort_hoor>Сортировка Хоора</a>/<a href=#e4>Пример</a><br>
<a href=#sort_quick>QuickSort</a>/<a href=#e5>Пример</a><br>
<a href=#sort_tree>Сортировка с помощью двоичного дерева</a>/<a href=#e6>Пример</a><br>
<a href=#sort_index>Сортировка с помощью массива индексов</a>/<a href=#e7>Пример</a><br>
<a href=#wstc>Какую сортировку выбрать</a>
</p>

<a name=intro>
<h2 align=center>Введение</h2>

<p>Этот текст призван стать кратким обзором нескольких алгоритмов сортировки.</p>

<p>Солидная часть статьи взята из одноименного текста С.Курковского,
что-то дописано, что-то поскипано, преобразовано в html,
добавлены пара алгоритмов с картинкой, примеры отлажены до рабочего состояния.</p>

<p>Итак, каждый алгоритм сортировки состоит из трех основных частей:</p>

<ul>
<li>Функция сравнения пары элементов сортируемого массива
<li>Процедура перестановки, меняющая местами пару элементов
<li>Сортирующий алгоритм, который осуществляет сравнение и перестановку
элементов до тех пор, пока все элементы множества не будут упорядочены.
</ul>

<pre><font color=#000080>
#define less(x,y)  (x &lt; y)              <i>// функция сравнения элементов</i>
#define swap(x,y)  {int t=x; x=y; y=t;} <i>// процедура перестановки элементов</i>
</font></pre>

<a name=sort_bubble>
<h2 align=center>Пузырьковая сортировка</h2>

<p>Операция сравнения/перестановки выполняется для каждых двух стоящих
рядом элементов.
После первого прохода по массиву "вверху" оказывается
самый "легкий" элемент.
Следующий цикл сортировки выполняется начиная со второго элемента,
в результате чего вторым в массиве оказывается второй наименьший
по величине элемент, и так далее.<br>
Алгоритм прост и крайне неэффективен.
</p>

<a name=e1>
<pre><font color=#000080>
void sort_bubble(int a[], int max)      <i>// пузырьковая сортировка</i>
  {
    for (int i=0; i&lt;max; i++)
    for (int j=max-1; j&gt;i; j--)
      if (less(a[j], a[j-1]))
        swap(a[j], a[j-1]);
  }
</font></pre>

<a name=sort_choose>
<h2 align=center>Сортировка выбором</h2>

<p>Во время i-го прохода по массиву выявляется наименьший элемент,
который затем меняется местами с i-м.<br>
Все остальное аналогично пузырьковой сортировке.</p>

<a name=e2>
<pre><font color=#000080>
void sort_choose(int a[], int max)      <i>// сортировка выбором</i>
  {
    for (int i=0; i&lt;max; i++)
      {
        int k=i;
        for (int j=i+1; j&lt;max; j++)
          if (less(a[j], a[k]))
            k=j;
        if (i!=k)
          swap(a[i], a[k]);
      }
  }
</font></pre>

<a name=sort_shell>
<h2 align=center>Сортировка Шелла</h2>

<p>Основная идея алгоритма заключается в том, чтобы вначале устранить
массовый беспорядок в массиве, сравнивая далеко стоящие друг от друга
элементы.<br>
Интервал между сравниваемыми элементами постепенно уменьшается до
единицы. Это означает, что на поздних стадиях сортировка сводится
просто к перестановкам соседних элементов.
</p>

<a name=e3>
<pre><font color=#000080>
void sort_shell(int a[], int max)               <i>// сортировка Шелла</i>
  {
    for (int gap = max/2; gap&gt;0; gap/=2)        <i>// выбор интервала</i>
      for (int i=gap; i&lt;max; i++)               <i>// проход массива</i>
<i>// сравнение пар, отстоящих на gap друг от друга</i>
        for (int j=i-gap; j&gt;=0 && less(a[j+gap],a[j]); j-=gap)
          swap(a[j], a[j+gap]);
  }
</font></pre>

<a name=sort_hoor>
<h2 align=center>Сортировка Хоора</h2>

<p>Суть метода заключается в том, чтобы найти такой элемент множества,
подлежащего сортировке, который разобьет его на два подмножества:
те элементы, что меньше делящего элемента, и те, что не меньше его.
</p>

<p>Для массива из 10 чисел установим два индекса:
на первый (i) и на последний (j) элементы.
</p>

<pre>
        10 7 28 49 31 25 17 3 14 43
        i                      &lt;--j
                           step==-1
</pre>

<p>На каждом шаге будем изменять значение индекса j на значение step
(вначале оно равно -1, индекс уменьшается), т.е. двигать j влево.
Мы будем делать так в том случае,
если j-й элемент больше, чем i-й элемент.
Если это условие не выполнено - поменяем местами i-й и j-й элементы массива
и сами индексы i и j, а также изменим знак у значения step -- оно станет
равным +1:
</p>

<pre>
        3 7 28 49 31 25 17 10 14 43
        j--&gt;               i
        step==+1
</pre>

<p>
Продолжим процесс: теперь j движется вправо,
и изменится условие - сейчас для продолжения процесса необходимо,
чтобы j-й элемент был меньше i-го.
</p>

<p>Будем продолжать вышеописанный процесс до тех пор, пока индексы i
и j не станут одинаковыми.
</p>

<p>В этот момент можно утверждать, что i-й
(он же и j-й) элемент разделил исходное множество на два
подмножества: все элементы, находящиеся слева от делящего
элемента, меньше его, и все элементы, находящиеся справа, не
меньше делящего (i-го) элемента. Получилось, что i-й элемент
стоит на своем месте:
</p>

<pre>
        3 7 10 49 31 25 17 28 14 43
            ij
</pre>

<p>Таким образом, мы описали процедуру нахождения расположения одного
элемента. Иными словами, мы "отсортировали" один элемент множества.
Такая же процедура применима к элементам "левого" и "правого"
подмножеств, которые на данный момент еще не отсортированы.
</p>

<p>Условие завершения нашей рекурсивной процедуры - совпадение границ,
которое эквивалентно тому, что в множестве остался один элемент.
</p>

<a name=e4>
<pre><font color=#000080>
void sort_hoor(int a[], int l, int r)   <i>// сортировка Хоора</i>
  {
    int i=l, j=r, step=-1, condition=1;
    if (l&gt;=r) return;                   <i>// сортировать нечего</i>

    do {                         <i>// сортируем с левой границы до правой</i>
      if (condition == less(a[j],a[i]))
        {
          swap(a[i], a[j]);             <i>// перестановка чисел</i>
          swap(i, j);                   <i>// обмен местами индексов</i>
          step = -step;                 <i>// теперь - в другую сторону</i>
          condition = !condition;       <i>// обмен условия на противоположное</i>
        }
      j += step;                        <i>// передвинем индекс</i>
    } while (j!=i);                     <i>// пока индексы не сойдутся</i>
    sort_hoor(a, l, i-1);               <i>// левое подмножество</i>
    sort_hoor(a, i+1, r);               <i>// правое</i>
  }
</font></pre>

<a name=sort_quick>
<h2 align=center>QuickSort</h2>

<p>По существу является разновидностью сортировки Хоора, но программная
реализация немного красивее и быстрее.</p>

<p>Основное отличие - за делящий элемент всегда выбирается середина массива.</p>

<a name=e5>
<pre><font color=#000080>
void sort_quick(int a[], int l, int r) <i>// QuickSort</i>
  {
    int i=l, j=r, x=a[(l+r)/2];
    do {
      while (less(a[i],x)) i++;
      while (less(x,a[j])) j--;
      if (i&lt;=j) {
        swap(a[i], a[j]);
        i++;
        j--;
      };
    } while (i&lt;j);
    if (l&lt;j) sort_quick(a,l,j);
    if (i&lt;r) sort_quick(a,i,r);
  }
</font></pre>

<a name=sort_tree>
<h2 align=center>Сортировка с помощью двоичного дерева</h2>

<p>Двоичным деревом назовем упорядоченную структуру
данных, в которой каждому элементу -- предшественнику или корню
(под)дерева  -- поставлены в соответствие по крайней мере два других
элемента (преемника). Причем для каждого предшественника выполнено
следующее правило: левый преемник всегда меньше, а правый преемник
всегда больше или равен предшественнику.
Если мы составим такое
дерево из букв слова "СОРТИР", сравнивая ASCII коды букв, то
получим следующую структуру:
</p>

<pre>
                                   С
                                 /   \
                                О     Т
                              /   \
                             И     Р
</pre>

<p>
Как видно, узел "С" имеет два
преемника: левый "О" и правый "Т". Если составить бинарное дерево
из элементов неупорядоченного массива, то в общем случае дерево
получится достаточно хорошо заполненным (а если массив
уже был рассортирован, то дерево выродится в линейный список).
Если мы будем обходить дерево по правилу "ЛЕВЫЙ преемник - КОРЕНЬ
- ПРАВЫЙ преемник", то, записывая все встречающиеся элементы в
массив, мы получим упорядоченное в порядке возрастания множество.
На этом и основана идея сортировки деревом.</p>

<p>Использование такой сортировки удобно тогда, когда удобно представлять данные
в виде дерева.</p>

<p>Недостаток метода - требуется много памяти.
В приведеном примере - дополнительный мегабайт данных на каждые 256k элементов.
</p>

<a name=e6>
<pre><font color=#000080>
<i>/*********** сортировка с помощью двоичного дерева *************/</i>

typedef struct tree
  {
    int a;              <i>// данные</i>
    struct tree *left;  <i>// левый  преемник</i>
    struct tree *right; <i>// правый преемник</i>
  } TREE;

TREE *add_to_tree(TREE *root, int new_value)
{
   if (root==NULL)  <i>// если дошли до корня - создаем новый элемент</i>
     {
        root = (TREE*)malloc(sizeof(TREE));
        root-&gt;a = new_value;
        root-&gt;left = root-&gt;right = 0;
        return root;
     }
   if less(root-&gt;a, new_value)          <i>// добавлем ветвь</i>
     root-&gt;right = add_to_tree(root-&gt;right, new_value);
   else
     root-&gt;left  = add_to_tree(root-&gt;left,  new_value);
   return root;
}

void tree_to_array(TREE *root, int a[]) <i>// процедура заполнения массива</i>
  {
    static max2=0;                      <i>// счетчик элементов нового массива</i>
    if (root==NULL) return;             <i>// условие окончания - найден корень</i>
    tree_to_array(root-&gt;left, a);       <i>// обход левого поддерева</i>
    a[max2++] = root-&gt;a;
    tree_to_array(root-&gt;right, a);      <i>// обход правого поддерева</i>
    free(root);
  }

void sort_tree(int a[], int max)        <i>// собственно сортировка</i>
{
   TREE *root = 0;
   for (int i=0; i&lt;max; i++)            <i>// проход массива и заполнение дерева</i>
      root = add_to_tree(root, a[i]);
   tree_to_array(root, a);              <i>// заполнение массива</i>
}
</font></pre>

<a name=sort_index>
<h2 align=center>Сортировка с помощью массива индексов</h2>

<p>Это не столько метод, сколько хинт для ускорения любого метода сортировки,
когда в качестве данных используются структуры большого размера.</p>

<p>Идея заключается в том, что параллельно с основным массивом данных существует
так называемый массив индексов, через который осуществляется перестановка
индексов основного массива данных.</p>

<pre><font color=#000080>
struct XPEH a[10000]; // основной массив
int index[10000];     // массив индексов {0,1,2,...,9999}
</font></pre>

<p>Перед сортировкой массив индексов инициализируется соответствующими
порядковыми номерами.</p>

<p>Доступ к массиву данных ведется не как a[i], а как a[index[i]],
и функция сравнения теперь выглядит иначе:</p>

<pre><font color=#000080>
#define less(i,j)  (a[index[i]].XPEH_member &lt; a[index[j]].XPEH_member)
</font></pre>

<p>В результате фактически сортируется массив с индексами, а не с данными.</p>

<a name=e7>
<pre><font color=#000080>
void sort_quick_index(XPEH a[], int index[], int l, int r)
  {
    int i=l, j=r, x=(l+r)/2;            <i>// теперь x не элемент а его индекс</i>
    do {
      while (less(i,x)) i++;
      while (less(x,j)) j--;
      if (i&lt;=j)
        {
          if (x==i) x==j; else if (x==j) x==i;
          swap(index[i], index[j]);     <i>// сортируем индексы</i>
          i++;
          j--;
        };
    } while (i&lt;j);
    if (l&lt;j) sort_quick_index(a,index,l,j);
    if (i&lt;r) sort_quick_index(a,index,i,r);
  }
</font></pre>

<p>А теперь сравните по скорости тысячу операций swap(x,y),
где в первом случае x и y - это большие структуры данных,
а во втором - числа по 2-4 байта.</p>

<a name=wstc>
<h2 align=center>Какую сортировку выбрать</h2>

<p>Ниже приведена зависимость скорости сортировки от числа элементов массива.
Эксперимент проводился на весьма торозном компьютере, так что верна лишь
пропорциональность скоростей.
Массив заполнялся случайными числами от 0 до N, где N - число элементов массива.</p>

<img border=0 src="sort.gif" usemap=#mymap><br>

<map name=mymap>
<area shape=rect coords="40,40,200,60" href=#sort_bubble>
<area shape=rect coords="45,95,180,120" href=#sort_choose>
<area shape=rect coords="270,320,390,350" href=#sort_shell>
<area shape=rect coords="270,410,390,430" href=#sort_hoor>
<area shape=rect coords="400,410,470,430" href=#sort_quick>
<area shape=rect coords="30,370,160,400" href=#sort_tree>
</map>

<p>Как видно, QuickSort показывает лучший результат по времени,
да и по реализации процедура сортировки весьма проста.</p>

<p>Таким образом лучшее решение - ассемблерный аналог QuickSortа,
с использованием массива индексов если структуры данных достаточно большие.</p>

<p>Примечание: не следует исходники сортировок понимать буквально,
ибо они далеки от совершенства.
В частности, в рекурсивных функциях сортируемый массив как параметр вовсе
не передается, и именно так было при построении графика.</p>

<p>И еще: в случае, если функция сравнения less(XPEH a,XPEH b) занимает много
времени, можно заранее просчитать "веса" элементов и функцию сравнения определить уже для них.<p>

<p align=rig